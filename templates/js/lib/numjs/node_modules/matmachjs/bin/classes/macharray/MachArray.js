"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("./types");
const MachUtil_1 = require("./MachUtil");
const MachRuntime_1 = require("./MachRuntime");
class MachArray extends Float64Array {
    get _mat_class() {
        return types_1.MatClass[this._type_attribute[0]];
    }
    get _mclass() {
        return types_1.MClass[this._type_attribute[2]];
    }
    get _order() {
        return (this._attributes[0] === 0) ? "C" : "R";
    }
    constructor(arr_ptr) {
        super(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(arr_ptr), MachRuntime_1._wi.numel(arr_ptr));
        this.header = new Int32Array(MachRuntime_1._wi.mem.buffer, arr_ptr, 7);
        this._type_attribute = new Uint8Array(MachRuntime_1._wi.mem.buffer, arr_ptr, 3);
        this._attributes = new Uint8Array(MachRuntime_1._wi.mem.buffer, arr_ptr + 24, 4);
        this._numel = this.header[1];
        this._ndim = this.header[3];
        this._headerOffset = arr_ptr;
        this._shape = new Float64Array(MachRuntime_1._wi.mem.buffer, this.header[4], this._ndim);
        this._strides = new Float64Array(MachRuntime_1._wi.mem.buffer, this.header[5], this._ndim);
    }
    clone() {
        let new_arr_ptr = MachRuntime_1._wi.clone(this._headerOffset);
        return new MachArray(new_arr_ptr);
    }
    get_index(...args) {
        return this[this.index(...args)];
    }
    set_index(args, value) {
        return this[this.index(...args)] = value;
    }
    index(...args) {
        if (args.length == 1)
            return args[0];
        if (args.length == 0)
            throw new Error("Must provide at least one index");
        return args.reduce((acc, val, i) => { return acc + val * this._strides[i]; }, 0);
    }
    slice_get(args) {
        let ptrs_to_free = [];
        let input_vector_ptr = MachRuntime_1._wi.create_mxvector(args.length, 5);
        ptrs_to_free.push(input_vector_ptr);
        let vector_input = new Uint32Array(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(input_vector_ptr), args.length);
        args.forEach((dim_arr, dim_arr_ind) => {
            let dim_input_ptr = MachRuntime_1._wi.create_mxvector(dim_arr.length);
            let dim_input = new Float64Array(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(dim_input_ptr), dim_arr.length);
            dim_arr.forEach((dim, dim_ind) => {
                dim_input[dim_ind] = dim;
            });
            vector_input[dim_arr_ind] = dim_input.byteOffset;
            ptrs_to_free.push(dim_input_ptr);
        });
        let ret = new MachArray(MachRuntime_1._wi.get_f64(vector_input.byteOffset));
        MachUtil_1.MachUtil.free_input_memory(MachRuntime_1._wi, ptrs_to_free);
        return ret;
    }
    slice_set(args, values) {
        let ptrs_to_free = [];
        let input_vector_ptr = MachRuntime_1._wi.create_mxvector(args.length, 5);
        ptrs_to_free.push(input_vector_ptr);
        let vector_input = new Uint32Array(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(input_vector_ptr), args.length);
        args.forEach((dim_arr, dim_arr_ind) => {
            let dim_input_ptr = MachRuntime_1._wi.create_mxvector(dim_arr.length);
            let dim_input = new Float64Array(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(dim_input_ptr), dim_arr.length);
            dim_arr.forEach((dim, dim_ind) => {
                dim_input[dim_ind] = dim;
            });
            vector_input[dim_arr_ind] = dim_input.byteOffset;
            ptrs_to_free.push(dim_input_ptr);
        });
        let input_values_ptr = MachRuntime_1._wi.create_mxvector(args.length);
        ptrs_to_free.push(input_values_ptr);
        let input_values = new Float64Array(MachRuntime_1._wi.mem.buffer, MachRuntime_1._wi.mxarray_core_get_array_ptr(input_values_ptr), values.length);
        values.forEach((val, index) => {
            input_values[index] = val;
        });
        MachRuntime_1._wi.set_f64(vector_input.byteOffset);
        MachUtil_1.MachUtil.free_input_memory(MachRuntime_1._wi, ptrs_to_free);
    }
    numel() {
        return this.length;
    }
    size() {
        return new Float64Array(this._shape);
    }
    ndims() {
        return this._shape.length;
    }
    dim_length() {
        let max = -Infinity;
        return this._shape.reduce((val) => (val > max) ? val : max, 0);
    }
    is_scalar() {
        return (this.length === 1);
    }
    isrow() {
        return MachRuntime_1._wi.isrow(this._headerOffset) === 1;
    }
    iscolumn() {
        return MachRuntime_1._wi.iscolumn(this._headerOffset) === 1;
    }
    ismatrix() {
        return MachRuntime_1._wi.ismatrix(this._headerOffset) === 1;
    }
    isvector() {
        return MachRuntime_1._wi.isvector(this._headerOffset) === 1;
    }
    isempty() {
        return this.length === 0;
    }
    reshape(newshape) {
        // TODO(dherre3): Past logic to wasm, invalid as it should also change strides and
        if (newshape.reduce((acc, dim) => dim * acc, 1) !== this._numel)
            throw new Error("New shape must have the same dimensions");
        newshape.forEach((dim, i) => {
            this._shape[i] = dim;
        });
        return this;
    }
    free() {
        MachRuntime_1._wi.free_macharray(this._headerOffset);
    }
    /**
     * Method returns whether the two arrays contain the same meta-data information,
     * It avoids comparing the dim_ptr and stride_ptr
     * @param {MachArray} that MachArray to compare against
     * @returns {boolean} whether the headers are equal for two MachArrays
     */
    header_equal(that) {
        return this.header[0] === that.header[0] && this.header[1] === that.header[1]
            && this.header[3] === that.header[3] && that.header[6] === that.header[6];
    }
}
exports.MachArray = MachArray;
